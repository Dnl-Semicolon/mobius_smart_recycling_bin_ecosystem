<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Wide Events Viewer</title>
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
        <script src="https://cdn.tailwindcss.com"></script>
        <style>
            :root {
                --ink: #17212b;
                --panel: rgba(255, 255, 255, 0.86);
                --border: rgba(15, 23, 42, 0.12);
                --accent: #1e7a78;
                --accent-strong: #145452;
                --success: #2f8f6d;
                --warn: #d9822b;
                --error: #d04c4c;
                --shadow: 0 18px 40px rgba(16, 24, 40, 0.12);
            }

            body {
                font-family: "Space Grotesk", sans-serif;
                color: var(--ink);
                background:
                    radial-gradient(900px 520px at 8% 12%, rgba(30, 122, 120, 0.16), transparent 60%),
                    radial-gradient(850px 520px at 90% 0%, rgba(217, 130, 43, 0.16), transparent 60%),
                    linear-gradient(180deg, #f7f3ec 0%, #f1efe8 100%);
            }

            .panel {
                background: var(--panel);
                border: 1px solid var(--border);
                box-shadow: var(--shadow);
                backdrop-filter: blur(10px);
            }

            .btn {
                display: inline-flex;
                align-items: center;
                justify-content: center;
                gap: 0.4rem;
                padding: 0.45rem 0.9rem;
                border-radius: 999px;
                font-weight: 600;
                font-size: 0.875rem;
                border: 1px solid transparent;
                transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease, color 120ms ease;
            }

            .btn-primary {
                background: var(--accent);
                color: #fff;
                box-shadow: 0 10px 18px rgba(30, 122, 120, 0.25);
            }

            .btn-primary:hover {
                background: var(--accent-strong);
                transform: translateY(-1px);
            }

            .btn-ghost {
                background: rgba(255, 255, 255, 0.8);
                border-color: rgba(15, 23, 42, 0.15);
                color: #1f2a33;
            }

            .btn-ghost:hover {
                transform: translateY(-1px);
            }

            .list-scroll::-webkit-scrollbar,
            .detail-scroll::-webkit-scrollbar {
                height: 10px;
                width: 10px;
            }

            .list-scroll::-webkit-scrollbar-thumb,
            .detail-scroll::-webkit-scrollbar-thumb {
                background: rgba(15, 23, 42, 0.25);
                border-radius: 999px;
            }
        </style>
    </head>
    <body class="min-h-screen overflow-x-hidden">
        <main class="mx-auto flex min-h-screen w-full max-w-300 flex-col gap-4 px-4 py-4 lg:flex-row lg:gap-6 lg:px-6 lg:py-6">
            <section class="panel flex h-[calc(100vh-3rem)] w-full min-w-0 flex-col gap-3 rounded-3xl p-3 lg:h-auto lg:max-h-[calc(100vh-3rem)] lg:w-[280px]">
                <div class="flex flex-wrap items-center gap-2">
                    <button id="reloadBtn" class="btn btn-primary" type="button">Reload</button>
                    <button id="pasteToggleBtn" class="btn btn-ghost" type="button">Paste</button>
                    <span id="countBadge" class="rounded-full bg-white/80 px-3 py-1 text-xs font-semibold text-slate-600">0</span>
                </div>

                <input
                    id="searchInput"
                    type="search"
                    placeholder="Search path / status / request_id"
                    class="w-full rounded-2xl border border-slate-200 bg-white/85 px-3 py-2 text-sm shadow-sm"
                >

                <details id="pastePanel" class="rounded-2xl border border-slate-200 bg-white/85 p-3 text-sm shadow-sm">
                    <summary class="cursor-pointer font-semibold text-slate-600">Paste JSONL</summary>
                    <textarea id="pasteInput" rows="6" class="mt-3 w-full resize-y rounded-xl border border-slate-200 bg-white/90 p-2 font-mono text-xs text-slate-700 shadow-inner"></textarea>
                    <div class="mt-3 flex flex-wrap gap-2">
                        <button id="loadPasteBtn" class="btn btn-ghost" type="button">Load pasted</button>
                        <button id="sampleBtn" class="btn btn-ghost" type="button">Use sample</button>
                    </div>
                </details>

                <div id="eventList" class="list-scroll flex-1 space-y-2 overflow-auto pr-1"></div>

                <button id="loadMoreBtn" class="btn btn-ghost w-full" type="button">Load more</button>
            </section>

            <section class="panel flex h-[calc(100vh-3rem)] w-full min-w-0 flex-col rounded-3xl p-4 lg:h-auto lg:max-h-[calc(100vh-3rem)] lg:flex-1">
                <div class="mb-3 flex flex-wrap items-center justify-between gap-2 text-xs text-slate-500">
                    <span id="detailSummary">Select an event</span>
                    <span id="detailMeta"></span>
                </div>
                <pre id="eventDetail" class="detail-scroll flex-1 overflow-auto whitespace-pre font-mono text-xs leading-5 text-slate-700"></pre>
            </section>
        </main>

        <script>
            const LOG_ENDPOINT = "/wide-events-log";
            const state = {
                events: [],
                filtered: [],
                selectedId: null,
                selectedKey: null,
                renderLimit: 400,
                searchTerm: "",
                isLoading: false,
            };

            const elements = {
                reloadBtn: document.getElementById("reloadBtn"),
                pasteToggleBtn: document.getElementById("pasteToggleBtn"),
                pastePanel: document.getElementById("pastePanel"),
                pasteInput: document.getElementById("pasteInput"),
                loadPasteBtn: document.getElementById("loadPasteBtn"),
                sampleBtn: document.getElementById("sampleBtn"),
                searchInput: document.getElementById("searchInput"),
                eventList: document.getElementById("eventList"),
                loadMoreBtn: document.getElementById("loadMoreBtn"),
                countBadge: document.getElementById("countBadge"),
                detailSummary: document.getElementById("detailSummary"),
                detailMeta: document.getElementById("detailMeta"),
                eventDetail: document.getElementById("eventDetail"),
            };

            function getEventKey(event) {
                if (event.parseError) {
                    return `parse:${event.raw}`;
                }
                const requestId = event.json?.trace?.request_id;
                if (requestId) {
                    return `req:${requestId}`;
                }
                return `raw:${event.raw}`;
            }

            function escapeHtml(value) {
                return value
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
            }

            function truncateLine(line, max = 220) {
                if (line.length <= max) {
                    return line;
                }
                return line.slice(0, max - 3) + "...";
            }

            function parseJsonLines(text) {
                const lines = text.split(/\r?\n/);
                const events = [];

                lines.forEach((line, index) => {
                    const trimmed = line.trim();
                    if (!trimmed) {
                        return;
                    }
                    try {
                        const json = JSON.parse(trimmed);
                        const timeValue = json.timing?.timestamp || json._meta?.emitted_at;
                        const timeMs = timeValue ? Date.parse(timeValue) : null;
                        events.push({
                            id: index + 1,
                            lineIndex: index + 1,
                            raw: trimmed,
                            json,
                            timeMs,
                            parseError: null,
                        });
                    } catch (error) {
                        events.push({
                            id: index + 1,
                            lineIndex: index + 1,
                            raw: trimmed,
                            json: null,
                            timeMs: null,
                            parseError: error instanceof Error ? error.message : "Unknown parse error",
                        });
                    }
                });

                events.sort((a, b) => {
                    const aKey = Number.isFinite(a.timeMs) ? a.timeMs : a.lineIndex;
                    const bKey = Number.isFinite(b.timeMs) ? b.timeMs : b.lineIndex;
                    return bKey - aKey;
                });

                return events;
            }

            function matchesSearch(event, term) {
                if (!term) {
                    return true;
                }
                const lower = term.toLowerCase();
                if (event.parseError) {
                    return event.raw.toLowerCase().includes(lower);
                }
                const json = event.json || {};
                const parts = [
                    json.http?.path,
                    json.http?.method,
                    json.http?.status_code,
                    json.trace?.request_id,
                    json.timing?.outcome,
                ];
                return parts
                    .filter((part) => part !== null && part !== undefined)
                    .map((part) => String(part).toLowerCase())
                    .some((part) => part.includes(lower));
            }

            function isErrorEvent(event) {
                if (event.parseError) {
                    return true;
                }
                const status = event.json?.http?.status_code;
                if (event.json?.timing?.outcome === "error") {
                    return true;
                }
                if (Number.isFinite(status) && status >= 400) {
                    return true;
                }
                return Boolean(event.json?.error);
            }

            function applyFilters() {
                state.filtered = state.events.filter((event) => matchesSearch(event, state.searchTerm));
                if (state.selectedKey) {
                    const match = state.filtered.find((event) => getEventKey(event) === state.selectedKey);
                    state.selectedId = match?.id ?? null;
                }
                if (!state.selectedId && state.filtered.length) {
                    state.selectedId = state.filtered[0].id;
                }
                if (state.selectedId) {
                    const selected = state.filtered.find((event) => event.id === state.selectedId);
                    state.selectedKey = selected ? getEventKey(selected) : null;
                }
                renderList();
                updateDetail();
            }

            function renderList() {
                const fragment = document.createDocumentFragment();
                const limited = state.filtered.slice(0, state.renderLimit);

                limited.forEach((event) => {
                    const isError = isErrorEvent(event);
                    const button = document.createElement("button");
                    button.type = "button";
                    button.dataset.eventId = String(event.id);

                    let tone = "bg-white/80 hover:bg-white border-slate-200 text-slate-700";
                    if (event.parseError) {
                        tone = "bg-amber-100/70 hover:bg-amber-100 border-amber-200 text-amber-900";
                    } else if (isError) {
                        tone = "bg-red-100/60 hover:bg-red-100 border-red-200 text-red-900";
                    } else {
                        tone = "bg-emerald-100/60 hover:bg-emerald-100 border-emerald-200 text-emerald-900";
                    }

                    if (event.id === state.selectedId) {
                        tone += " ring-2 ring-offset-1 ring-slate-900/10";
                    }

                    const displayLine = event.parseError
                        ? `PARSE ERROR: ${event.raw}`
                        : event.raw;

                    button.className = `w-full rounded-2xl border px-3 py-2 text-left shadow-sm transition ${tone}`;
                    button.innerHTML = `
                        <span class="block truncate font-mono text-xs leading-5" title="${escapeHtml(displayLine)}">
                            ${escapeHtml(truncateLine(displayLine))}
                        </span>
                    `;

                    fragment.appendChild(button);
                });

                elements.eventList.innerHTML = "";
                elements.eventList.appendChild(fragment);
                elements.loadMoreBtn.disabled = state.renderLimit >= state.filtered.length;
                elements.loadMoreBtn.textContent = state.renderLimit >= state.filtered.length ? "All loaded" : "Load more";
                elements.countBadge.textContent = `${state.filtered.length}`;
            }

            function updateDetail() {
                if (!state.selectedId) {
                    elements.detailSummary.textContent = "Select an event";
                    elements.detailMeta.textContent = "";
                    elements.eventDetail.textContent = "";
                    return;
                }

                const event = state.filtered.find((item) => item.id === state.selectedId);
                if (!event) {
                    return;
                }

                const http = event.json?.http || {};
                const timing = event.json?.timing || {};
                const trace = event.json?.trace || {};

                elements.detailSummary.textContent = event.parseError
                    ? "Parse error"
                    : `${http.method || "--"} ${http.path || "--"} â€” ${http.status_code ?? "--"}`;
                elements.detailMeta.textContent = `${trace.request_id || "--"}  ${timing.duration_ms ?? "--"}ms`;

                if (event.parseError) {
                    elements.eventDetail.textContent = `Parse error: ${event.parseError}\n\nRaw line:\n${event.raw}`;
                    return;
                }

                elements.eventDetail.textContent = JSON.stringify(event.json, null, 2);
            }

            async function loadFromEndpoint() {
                if (state.isLoading) {
                    return;
                }
                state.isLoading = true;
                elements.detailSummary.textContent = "Loading...";
                elements.eventDetail.textContent = "";
                try {
                    const response = await fetch(LOG_ENDPOINT, { cache: "no-store" });
                    if (!response.ok) {
                        throw new Error(`Failed to fetch log (${response.status})`);
                    }
                    const text = await response.text();
                    state.events = parseJsonLines(text);
                    state.renderLimit = 400;
                    applyFilters();
                } catch (error) {
                    elements.detailSummary.textContent = "Unable to load log";
                    elements.detailMeta.textContent = "";
                    elements.eventDetail.textContent = error instanceof Error
                        ? error.message
                        : "Unknown error.";
                } finally {
                    state.isLoading = false;
                }
            }

            function loadFromText(text) {
                state.events = parseJsonLines(text);
                state.renderLimit = 400;
                applyFilters();
            }

            elements.reloadBtn.addEventListener("click", () => {
                loadFromEndpoint();
            });

            elements.pasteToggleBtn.addEventListener("click", () => {
                elements.pastePanel.open = !elements.pastePanel.open;
            });

            elements.loadPasteBtn.addEventListener("click", () => {
                const text = elements.pasteInput.value;
                if (!text.trim()) {
                    alert("Paste JSONL first.");
                    return;
                }
                loadFromText(text);
            });

            elements.sampleBtn.addEventListener("click", () => {
                const sample = [
                    "{\"_meta\":{\"emitted_at\":\"2026-01-17T16:30:45.123Z\"},\"trace\":{\"request_id\":\"req-123\"},\"http\":{\"method\":\"GET\",\"path\":\"api/v1/persons\",\"status_code\":200},\"timing\":{\"timestamp\":\"2026-01-17T16:30:45.000Z\",\"duration_ms\":45.2,\"outcome\":\"success\"},\"business\":{\"person\":{\"id\":5}}}",
                    "{\"_meta\":{\"emitted_at\":\"2026-01-17T16:31:12.555Z\"},\"trace\":{\"request_id\":\"req-124\"},\"http\":{\"method\":\"POST\",\"path\":\"api/v1/persons\",\"status_code\":422},\"timing\":{\"timestamp\":\"2026-01-17T16:31:12.000Z\",\"duration_ms\":30.1,\"outcome\":\"error\"},\"business\":{\"validation\":{\"failed\":true,\"fields\":[\"name\",\"phone\"]}}}",
                ].join("\n");
                elements.pasteInput.value = sample;
                loadFromText(sample);
            });

            elements.searchInput.addEventListener("input", (event) => {
                state.searchTerm = event.target.value;
                applyFilters();
            });

            elements.loadMoreBtn.addEventListener("click", () => {
                state.renderLimit += 400;
                renderList();
            });

            elements.eventList.addEventListener("click", (event) => {
                const button = event.target.closest("button[data-event-id]");
                if (!button) {
                    return;
                }
                state.selectedId = Number(button.dataset.eventId);
                const selected = state.filtered.find((item) => item.id === state.selectedId);
                state.selectedKey = selected ? getEventKey(selected) : null;
                renderList();
                updateDetail();
            });

            loadFromEndpoint();
        </script>
    </body>
</html>
